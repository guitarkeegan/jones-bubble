package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Define location data (asset name, display name, distance, position)
type locData struct {
	asset string
	name  string
	dist  int
	pos   int
}

var block1 = lipgloss.NewStyle().
	Background(lipgloss.Color("57")).
	Padding(1)

var block2 = lipgloss.NewStyle().
	Background(lipgloss.Color("213")).
	Padding(1)

var block3 = lipgloss.NewStyle().
	Background(lipgloss.Color("42")).
	Padding(1)

var block4 = lipgloss.NewStyle().
	Background(lipgloss.Color("208")).
	Padding(1)

var block5 = lipgloss.NewStyle().
	Background(lipgloss.Color("171")).
	Padding(1).
	Render("Block 5")

type location struct {
	img              string
	name             string
	relativeDistance int
	pos              int
}

type Accommodator interface {
	HowMuch() int
	PayRent(payment int) int
	Rest(time int) int
	Talk(event string) string
	Evict(p player) int
}

type Employer interface {
	Apply(edu, exp int) bool
	Work(time int) int
	Promote(p player) int
	Quit()
	Talk(event string) string
}

type Seller[T any] interface {
	Buy(money int) T
	Talk(event string) string
}

type Buyer[T any] interface {
	Sell(item T) int
	Talk(event string) string
}

type GameBoard struct {
	luxuryApartments location
	rentOffice       location
	lowCostHousing   location
	pawnShop         location
	zMart            location
	monolith         location
	qtClothing       location
	socketCity       location
	hiTechU          location
	employmentOffice location
	factory          location
	bank             location
	blacksMarket     location
}

type GameModel struct {
	Board     *GameBoard
	GameState GameState
}

func loadLocationFile(name string) string {
	filePath := filepath.Join("assets", fmt.Sprintf("Location_%s", name))
	content, err := os.ReadFile(filePath)
	if err != nil {
		// Log the error but don't crash the application
		log.Printf("WARNING: Failed to load location file %s: %v", filePath, err)
		// Return a placeholder or default content instead
		return fmt.Sprintf("[Missing asset for %s]", name)
	}
	return string(content)
}

func initializeLocations() *GameBoard {

	// Map location fields to their data
	locationMap := map[string]locData{
		"luxuryApartments": {"SecurityApartments", "Luxury Apartments", 0, 0},
		"rentOffice":       {"RentOffice", "Rent Office", 1, 1},
		"lowCostHousing":   {"LowCostHousing", "Low Cost Housing", 2, 2},
		"pawnShop":         {"PawnShop", "Pawn Shop", 3, 3},
		"zMart":            {"ZMart", "Z-Mart", 4, 4},
		"monolith":         {"Monolith", "Monolith", 5, 5},
		"qtClothing":       {"QTClothing", "QT Clothing", 6, 6},
		"socketCity":       {"SocketCity", "Socket City", 7, 7},
		"hiTechU":          {"HiTechU", "Hi-Tech University", 8, 8},
		"employmentOffice": {"EmploymentOffice", "Employment Office", 9, 9},
		"factory":          {"Factory", "Factory", 10, 10},
		"bank":             {"Bank", "Bank", 11, 11},
		"blacksMarket":     {"BlacksMarket", "Black's Market", 12, 12},
	}

	// Create board using the location map
	return &GameBoard{
		luxuryApartments: createLocation(locationMap["luxuryApartments"]),
		rentOffice:       createLocation(locationMap["rentOffice"]),
		lowCostHousing:   createLocation(locationMap["lowCostHousing"]),
		pawnShop:         createLocation(locationMap["pawnShop"]),
		zMart:            createLocation(locationMap["zMart"]),
		monolith:         createLocation(locationMap["monolith"]),
		qtClothing:       createLocation(locationMap["qtClothing"]),
		socketCity:       createLocation(locationMap["socketCity"]),
		hiTechU:          createLocation(locationMap["hiTechU"]),
		employmentOffice: createLocation(locationMap["employmentOffice"]),
		factory:          createLocation(locationMap["factory"]),
		bank:             createLocation(locationMap["bank"]),
		blacksMarket:     createLocation(locationMap["blacksMarket"]),
	}
}

func createLocation(data locData) location {
	return location{
		img:              loadLocationFile(data.asset),
		name:             data.name,
		relativeDistance: data.dist,
		pos:              data.pos,
	}
}

func NewGameModel() *GameModel {
	return &GameModel{
		Board:     initializeLocations(),
		GameState: initializingMap,
	}
}

func (gm GameModel) Init() tea.Cmd {
	return mapInitialized.Cmd
}

func (gm GameModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {

	dbg(fmt.Sprintf("update state: %[1]s | msg/type: %[2]v/%[2]T", gm.GameState, msg))

	switch msg := msg.(type) {

	case GameStateMsg:
		switch msg {
		case mapInitialized:
		case turnStarted:

		}
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c":
			return gm, exitRequested.Cmd
		}
	}

	switch gm.GameState {
	case initializingMap:
		return gm, nil
	default:
		return gm, nil
	}

}

// Location type enumeration
type LocationType int

const (
	Housing LocationType = iota
	Shopping
	Education
	Work
	Finance
	Entertainment
)

// View function for GameModel
func (gm GameModel) View() string {
	dbg("gm: View")

	switch gm.GameState {
	case initializingMap:
		// Base styles
		baseLocationStyle := lipgloss.NewStyle().
			Padding(1).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("240")).
			Width(20).
			Height(12)

		// Game action area style
		centerStyle := lipgloss.NewStyle().
			Background(lipgloss.Color("236")).
			Foreground(lipgloss.Color("252")).
			Border(lipgloss.DoubleBorder()).
			BorderForeground(lipgloss.Color("240")).
			Padding(2).
			Width(40).
			Height(25).
			Align(lipgloss.Center).
			AlignVertical(lipgloss.Center)

		// Create a map for our locations with their types
		locationTypes := map[string]LocationType{
			"luxuryApartments": Housing,
			"rentOffice":       Housing,
			"lowCostHousing":   Housing,
			"pawnShop":         Shopping,
			"zMart":            Shopping,
			"monolith":         Entertainment,
			"qtClothing":       Shopping,
			"socketCity":       Shopping,
			"hiTechU":          Education,
			"employmentOffice": Work,
			"factory":          Work,
			"bank":             Finance,
			"blacksMarket":     Shopping,
		}

		// Match location field names to actual location objects
		locationMap := map[string]location{
			"luxuryApartments": gm.Board.luxuryApartments,
			"rentOffice":       gm.Board.rentOffice,
			"lowCostHousing":   gm.Board.lowCostHousing,
			"pawnShop":         gm.Board.pawnShop,
			"zMart":            gm.Board.zMart,
			"monolith":         gm.Board.monolith,
			"qtClothing":       gm.Board.qtClothing,
			"socketCity":       gm.Board.socketCity,
			"hiTechU":          gm.Board.hiTechU,
			"employmentOffice": gm.Board.employmentOffice,
			"factory":          gm.Board.factory,
			"bank":             gm.Board.bank,
			"blacksMarket":     gm.Board.blacksMarket,
		}

		// Render location with appropriate style based on type
		renderLocation := func(locName string) string {
			loc := locationMap[locName]
			locType := locationTypes[locName]

			var style lipgloss.Style

			// Apply different background colors based on location type
			switch locType {
			case Housing:
				style = baseLocationStyle.
					Background(lipgloss.Color("25")). // Blue
					BorderForeground(lipgloss.Color("33"))
			case Shopping:
				style = baseLocationStyle.
					Background(lipgloss.Color("22")). // Green
					BorderForeground(lipgloss.Color("34"))
			case Education:
				style = baseLocationStyle.
					Background(lipgloss.Color("90")). // Purple
					BorderForeground(lipgloss.Color("93"))
			case Work:
				style = baseLocationStyle.
					Background(lipgloss.Color("94")). // Orange
					BorderForeground(lipgloss.Color("208"))
			case Finance:
				style = baseLocationStyle.
					Background(lipgloss.Color("136")). // Yellow
					BorderForeground(lipgloss.Color("178"))
			case Entertainment:
				style = baseLocationStyle.
					Background(lipgloss.Color("161")). // Pink
					BorderForeground(lipgloss.Color("200"))
			}

			// Prepare the art and name with proper formatting
			art := formatAsciiArt(loc.img, 18, 8)
			nameStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))

			return style.Render(
				art + "\n" +
					nameStyle.Render(loc.name),
			)
		}

		// Center game action area
		gameActionTitle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("99")).Render("GAME ACTION")
		centerArea := centerStyle.Render(
			gameActionTitle + "\n\n" +
				"Welcome to the game!\n\n" +
				"Navigate the city and build your life.\n\n" +
				"Press q to quit",
		)

		// Layout - Top row
		topRow := lipgloss.JoinHorizontal(
			lipgloss.Top,
			renderLocation("hiTechU"),
			renderLocation("luxuryApartments"),
			renderLocation("rentOffice"),
		)

		// Layout - Bottom row
		bottomRow := lipgloss.JoinHorizontal(
			lipgloss.Bottom,
			renderLocation("employmentOffice"),
			renderLocation("factory"),
			renderLocation("bank"),
		)

		// Layout - Left column
		leftCol := lipgloss.JoinVertical(
			lipgloss.Left,
			renderLocation("socketCity"),
			renderLocation("zMart"),
			renderLocation("blacksMarket"),
		)

		// Layout - Right column
		rightCol := lipgloss.JoinVertical(
			lipgloss.Right,
			renderLocation("lowCostHousing"),
			renderLocation("qtClothing"),
			renderLocation("pawnShop"),
		)

		// Join the middle section
		middleSection := lipgloss.JoinHorizontal(
			lipgloss.Center,
			leftCol,
			centerArea,
			rightCol,
		)

		// Final assembly - join everything
		boardStyle := lipgloss.NewStyle().
			Padding(1).
			Background(lipgloss.Color("234")) // Dark background for entire board

		return boardStyle.Render(
			lipgloss.JoinVertical(
				lipgloss.Center,
				topRow,
				middleSection,
				bottomRow,
			),
		)

	case startingTurn:
		return fmt.Sprintln("starting turn...")

	default:
		return fmt.Sprintf("gameState not handled: %s\n", gm.GameState)
	}
}

// Helper function to format ASCII art to fit within a certain width and height
func formatAsciiArt(art string, maxWidth, maxHeight int) string {
	lines := strings.Split(art, "\n")

	// If too many lines, truncate
	if len(lines) > maxHeight {
		lines = lines[:maxHeight]
	}

	// Pad with empty lines if too few
	for len(lines) < maxHeight {
		lines = append(lines, "")
	}

	// Truncate each line to max width and ensure consistent length
	for i, line := range lines {
		if len(line) > maxWidth {
			lines[i] = line[:maxWidth]
		}

		// Pad with spaces if too short
		for len(lines[i]) < maxWidth {
			lines[i] += " "
		}
	}

	return strings.Join(lines, "\n")
}
